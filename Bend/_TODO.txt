----

----[ TODO ]---------

- incremental merge (small step, eventually does a full merge)

  - cleanup
    - use SegmentDescriptor class everywhere

  - make "new" merge all produce the same performance as "old" merge all with numgen-hack
	- collapse max-generation number when possible?
	- keep a list of "live generations"?
	- re-order segmentdescriptors to put key first, gen last?  

  - cleanup
    - should recordKey return deleted records?
      - check that record-find is ignoring tombstones
    - remove old "mergeAllSegments" code
    - proper merge unit-test
    - drop tombstones when writing "oldest" generation



- block visualizer
  - C# gdi+ article  http://www.codeproject.com/KB/books/1861004990.aspx


- freelist
  - cleaner way to handle code and encoding of stored data, such as block pointers, freelist.. (binstruct?)
  - 'real' freelist handling

- simple text-indexer API on-top


*** row attributes for MVCC and locks
(a) introduce row-attribute concept (can affect commit, row visibility, etc.)
(b) attach MVCC attribute handler to writes, attach txn id to each row
(c) txn-id and MVCC attribute can transparently 'fall off' a row if txn commits, 

- prototype search-engine?


- age-out tombstones when in oldest generation (remember oldest gen #?)


--------[ Bigger TODO items ]-----------

*** First Automated Replication
(a) 'lock' for old generations (i.e. checkpoint),
(b) copy locked data to replica
(c) create new 'lock' for newer data, goto (b), until we are up-to-date

*** try using C# sqlite sql implementation to throw SQL on top



----[ DONE ]---------

11/3 - first incremental block merge works