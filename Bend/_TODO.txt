----

----[ TODO ]---------

- working on incremental merge



  - fix runaway max-generation issue....  
     Q: How to make "new" merge all produce the same performance as "old" merge all with numgen-hack
	   - collapse max-generation number when possible?
	   - keep a list of "live generations"?


  - cleanup    
    - use SegmentDescriptor class everywhere	
	- make a SegmentPointer class that contains magic/address/length/checksum, to handle segment pointers
	
	- write a layertest for the deletion tombstone-shadow problem    
    - remove old "mergeAllSegments" code
    - proper merge unit-test
    - drop tombstones when writing "oldest" generation
	

	- scanForward/scanBackward should really have easy to use >/< operators in addition to <=/>=

	Q: what should be the type of keyparts? 
    Q: How do we assure a valid merge? (no generation inversion because of partial keyranges)
       - code to check that using the min-gen for a merge output is valid?

- simple text-indexer test

- raw-byterange RegionManager
  - bounds checking on log-write, circular log, log-extension capability
  - bounds checking on segment size
  - encode segment length in SegmentInfo

- freelist
  - 'real' freelist handling
  - cleaner way to handle code and encoding of stored data, such as block pointers, freelist.. (binstruct?)



*** row attributes for MVCC and locks
(a) introduce row-attribute concept (can affect commit, row visibility, etc.)
(b) attach MVCC attribute handler to writes, attach txn id to each row
(c) txn-id and MVCC attribute can transparently 'fall off' a row if txn commits, 

- prototype search-engine?


- age-out tombstones when in oldest generation (remember oldest gen #?)


--------[ Bigger TODO items ]-----------

*** First Automated Replication
(a) 'lock' for old generations (i.e. checkpoint),
(b) copy locked data to replica
(c) create new 'lock' for newer data, goto (b), until we are up-to-date

*** try using C# sqlite sql implementation to throw SQL on top

- fix update semantics so "setValue" doesn't hack the value directly into the in-memory segment. It should simply commit the change packet and handleCommand() should cause the write to occur, just as it does in recovery. (i.e. recovery is the same as update)
- SegmentWriter needs buffered output (LogAppendWriter) - there was some problem with just dropping a buffered stream in place of the current streams
- Singleton keyparts for less allocation + faster comparisons
- stats tracking (qps, w_qps at 1 second interval)


----[ DONE ]---------


11/20 - added merge manager 'key histogram' merge-ratio computation as a fallback
11/20 - first incremental merge manager (+prevent holes from 'blocking' merges)
11/18 - make a "big test case" that shows off multiple layers of segments merging, with a debug visualization UI!
11/3 - first incremental block merge works
